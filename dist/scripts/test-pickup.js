"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const mongoose_1 = __importDefault(require("mongoose"));
const dotenv_1 = __importDefault(require("dotenv"));
const Order_1 = __importDefault(require("../models/Order"));
const Canteen_1 = __importDefault(require("../models/Canteen"));
const User_1 = __importDefault(require("../models/User"));
const MenuItem_1 = __importDefault(require("../models/MenuItem"));
const qrGenerator_1 = require("../utils/qrGenerator");
const order_controller_1 = require("../controllers/order.controller");
dotenv_1.default.config();
const mockRequest = (body, user) => ({
    body,
    user,
    headers: {}
});
const mockResponse = () => {
    const res = {};
    res.status = (code) => {
        res.statusCode = code;
        return res;
    };
    res.json = (data) => {
        res.data = data;
        return res;
    };
    return res;
};
const runTest = async () => {
    try {
        if (!process.env.MONGO_URI)
            throw new Error('MONGO_URI missing');
        await mongoose_1.default.connect(process.env.MONGO_URI);
        console.log('✅ Connected to MongoDB');
        // 1. Setup Data
        // Find a user and canteen (or create dummy ones if needed, but assuming they exist from previous steps)
        const user = await User_1.default.findOne({ role: 'admin' }); // Use admin to have permissions
        if (!user)
            throw new Error('No admin user found to test with');
        const canteen = await Canteen_1.default.findOne();
        if (!canteen)
            throw new Error('No canteen found');
        const menuItem = await MenuItem_1.default.findOne({ canteenId: canteen._id });
        if (!menuItem)
            throw new Error('No menu item found');
        // 2. Create a "Paid" Order
        const order = await Order_1.default.create({
            userId: user._id,
            canteenId: canteen._id,
            items: [{
                    menuItemId: menuItem._id,
                    name: menuItem.name,
                    price: menuItem.price,
                    quantity: 1
                }],
            totalAmount: menuItem.price,
            status: 'pending',
            paymentStatus: 'success', // Simulate paid
            paymentId: 'pay_test_123'
        });
        console.log(`✅ Created Test Order: ${order.orderId}`);
        // 3. Generate QR Data (as if generated by system)
        const qrCodeUrl = await (0, qrGenerator_1.generateOrderQR)(order.orderId);
        // Extract the payload from the data URL? No, generateOrderQR returns image.
        // We need the raw data that goes INTO the QR.
        // Wait, generateOrderQR returns a Data URL image.
        // The verifyController expects `qrData` which is the JSON string.
        // Let's look at `generateOrderQR` implementation.
        // It creates `qrData` JSON string, then passes it to `QRCode.toDataURL`.
        // We need to replicate the payload generation logic here to pass it to the controller.
        const crypto = require('crypto');
        const secret = process.env.JWT_SECRET || 'secret';
        const timestamp = Date.now();
        const payload = JSON.stringify({
            orderId: order.orderId,
            timestamp,
        });
        const signature = crypto.createHmac('sha256', secret).update(payload).digest('hex');
        const validQrJson = JSON.stringify({
            orderId: order.orderId,
            timestamp,
            signature,
        });
        console.log('✅ Generated Valid QR Data');
        // 4. Test Verify Endpoint (Scan)
        console.log('\n--- Testing Verify (Scan) ---');
        const reqVerify = mockRequest({ qrData: validQrJson }, user);
        const resVerify = mockResponse();
        await (0, order_controller_1.verifyOrderQR)(reqVerify, resVerify);
        if (resVerify.statusCode === 200) {
            console.log('✅ Verification Successful');
            console.log('Status:', resVerify.data.data.status); // Should be pending
        }
        else {
            console.error('❌ Verification Failed:', resVerify.data);
            process.exit(1);
        }
        // 5. Test Pickup Endpoint (Redeem)
        console.log('\n--- Testing Pickup (Redeem) ---');
        const reqPickup = mockRequest({ qrData: validQrJson }, user);
        const resPickup = mockResponse();
        await (0, order_controller_1.completeOrderPickup)(reqPickup, resPickup);
        if (resPickup.statusCode === 200) {
            console.log('✅ Pickup Successful');
            console.log('Message:', resPickup.data.message);
            console.log('New Status:', resPickup.data.data.status); // Should be completed
        }
        else {
            console.error('❌ Pickup Failed:', resPickup.data);
            process.exit(1);
        }
        // 6. Test Pickup Again (Should Fail - Expired)
        console.log('\n--- Testing Re-use (Should Fail) ---');
        const resReUse = mockResponse();
        await (0, order_controller_1.completeOrderPickup)(reqPickup, resReUse);
        if (resReUse.statusCode === 400 && resReUse.data.error.includes('already picked up')) {
            console.log('✅ Re-use Blocked Successfully (Expired)');
        }
        else {
            console.error('❌ Failed to block re-use:', resReUse.data);
            process.exit(1);
        }
        console.log('\n✅ All Tests Passed');
        // Cleanup
        await Order_1.default.findByIdAndDelete(order._id);
        console.log('Cleanup done');
        process.exit(0);
    }
    catch (error) {
        console.error('Test Failed:', error);
        process.exit(1);
    }
};
runTest();
//# sourceMappingURL=test-pickup.js.map