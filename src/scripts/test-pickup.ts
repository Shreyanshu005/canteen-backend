import mongoose from 'mongoose';
import dotenv from 'dotenv';
import Order from '../models/Order';
import Canteen from '../models/Canteen';
import User from '../models/User';
import MenuItem from '../models/MenuItem';
import { generateOrderQR } from '../utils/qrGenerator';
import { verifyOrderQR, completeOrderPickup } from '../controllers/order.controller';
import { Request, Response } from 'express';

dotenv.config();

const mockRequest = (body: any, user: any) => ({
    body,
    user,
    headers: {}
} as unknown as Request);

const mockResponse = () => {
    const res: any = {};
    res.status = (code: number) => {
        res.statusCode = code;
        return res;
    };
    res.json = (data: any) => {
        res.data = data;
        return res;
    };
    return res as Response & { statusCode: number; data: any };
};

const runTest = async () => {
    try {
        if (!process.env.MONGO_URI) throw new Error('MONGO_URI missing');
        await mongoose.connect(process.env.MONGO_URI);
        console.log('✅ Connected to MongoDB');

        // 1. Setup Data
        // Find a user and canteen (or create dummy ones if needed, but assuming they exist from previous steps)
        const user = await User.findOne({ role: 'admin' }); // Use admin to have permissions
        if (!user) throw new Error('No admin user found to test with');

        const canteen = await Canteen.findOne();
        if (!canteen) throw new Error('No canteen found');

        const menuItem = await MenuItem.findOne({ canteenId: canteen._id });
        if (!menuItem) throw new Error('No menu item found');

        // 2. Create a "Paid" Order
        const order = await Order.create({
            userId: user._id,
            canteenId: canteen._id,
            items: [{
                menuItemId: menuItem._id,
                name: menuItem.name,
                price: menuItem.price,
                quantity: 1
            }],
            totalAmount: menuItem.price,
            status: 'pending',
            paymentStatus: 'success', // Simulate paid
            paymentId: 'pay_test_123'
        });
        console.log(`✅ Created Test Order: ${order.orderId}`);

        // 3. Generate QR Data (as if generated by system)
        const qrCodeUrl = await generateOrderQR(order.orderId);
        // Extract the payload from the data URL? No, generateOrderQR returns image.
        // We need the raw data that goes INTO the QR.
        // Wait, generateOrderQR returns a Data URL image.
        // The verifyController expects `qrData` which is the JSON string.
        // Let's look at `generateOrderQR` implementation.
        // It creates `qrData` JSON string, then passes it to `QRCode.toDataURL`.
        // We need to replicate the payload generation logic here to pass it to the controller.

        const crypto = require('crypto');
        const secret = process.env.JWT_SECRET || 'secret';
        const timestamp = Date.now();
        const payload = JSON.stringify({
            orderId: order.orderId,
            timestamp,
        });
        const signature = crypto.createHmac('sha256', secret).update(payload).digest('hex');
        const validQrJson = JSON.stringify({
            orderId: order.orderId,
            timestamp,
            signature,
        });

        console.log('✅ Generated Valid QR Data');

        // 4. Test Verify Endpoint (Scan)
        console.log('\n--- Testing Verify (Scan) ---');
        const reqVerify = mockRequest({ qrData: validQrJson }, user);
        const resVerify = mockResponse();

        await verifyOrderQR(reqVerify, resVerify);

        if (resVerify.statusCode === 200) {
            console.log('✅ Verification Successful');
            console.log('Status:', resVerify.data.data.status); // Should be pending
        } else {
            console.error('❌ Verification Failed:', resVerify.data);
            process.exit(1);
        }

        // 5. Test Pickup Endpoint (Redeem)
        console.log('\n--- Testing Pickup (Redeem) ---');
        const reqPickup = mockRequest({ qrData: validQrJson }, user);
        const resPickup = mockResponse();

        await completeOrderPickup(reqPickup, resPickup);

        if (resPickup.statusCode === 200) {
            console.log('✅ Pickup Successful');
            console.log('Message:', resPickup.data.message);
            console.log('New Status:', resPickup.data.data.status); // Should be completed
        } else {
            console.error('❌ Pickup Failed:', resPickup.data);
            process.exit(1);
        }

        // 6. Test Pickup Again (Should Fail - Expired)
        console.log('\n--- Testing Re-use (Should Fail) ---');
        const resReUse = mockResponse();
        await completeOrderPickup(reqPickup, resReUse);

        if (resReUse.statusCode === 400 && resReUse.data.error.includes('already picked up')) {
            console.log('✅ Re-use Blocked Successfully (Expired)');
        } else {
            console.error('❌ Failed to block re-use:', resReUse.data);
            process.exit(1);
        }

        console.log('\n✅ All Tests Passed');

        // Cleanup
        await Order.findByIdAndDelete(order._id);
        console.log('Cleanup done');
        process.exit(0);

    } catch (error) {
        console.error('Test Failed:', error);
        process.exit(1);
    }
};

runTest();
